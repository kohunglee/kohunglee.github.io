<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>极简阴影</title>
<style>body{margin:0;overflow:hidden;}</style>
</head>
<body>
<canvas id="glcanvas" width="600" height="400"></canvas>
<script>
// WebGL上下文的“魔法师”：帮助我们和GPU对话
function getWebGLContext(c){let g=c.getContext("webgl")||c.getContext("experimental-webgl");if(!g){console.log("无法召唤WebGL魔法师");return null;}return g;}
// 着色器程序的“编剧”：把顶点和片元的故事写成程序
function createProgram(g,v,f){let vS=g.createShader(g.VERTEX_SHADER);g.shaderSource(vS,v);g.compileShader(vS);let fS=g.createShader(g.FRAGMENT_SHADER);g.shaderSource(fS,f);g.compileShader(fS);let p=g.createProgram();g.attachShader(p,vS);g.attachShader(p,fS);g.linkProgram(p);if(!g.getProgramParameter(p,g.LINK_STATUS)){console.log("剧本编写失败: "+g.getProgramInfoLog(p));g.deleteProgram(p);g.deleteShader(vS);g.deleteShader(fS);return null;}return p;}

// 矩阵的“变形金刚”：负责所有物体的空间变换魔法
class Matrix4 {
    constructor() { this.e = new Float32Array(16); this.setIdentity(); } // 我是16个元素的队伍，先排成“站立”姿态
    setIdentity() { const e=this.e;e[0]=e[5]=e[10]=e[15]=1;e[1]=e[2]=e[3]=e[4]=e[6]=e[7]=e[8]=e[9]=e[11]=e[12]=e[13]=e[14]=0; return this; } // “站立”姿态：不施加任何变化
    set(o) { this.e.set(o.e); return this; } // 复制另一个矩阵的“记忆”（元素），这是修复错误的关键！
    setOrtho(l,r,b,t,n,f){const e=this.e,w=1/(r-l),h=1/(t-b),p=1/(f-n);e[0]=2*w;e[1]=0;e[2]=0;e[3]=0;e[4]=0;e[5]=2*h;e[6]=0;e[7]=0;e[8]=0;e[9]=0;e[10]=-2*p;e[11]=0;e[12]=-(r+l)*w;e[13]=-(t+b)*h;e[14]=-(f+n)*p;e[15]=1;return this;} // 光源的“透视眼”：让光线笔直地投射
    setPerspective(fovy, aspect, near, far) { const e=this.e,s=1/Math.tan(fovy*Math.PI/360),_f=1/(near-far);e[0]=s/aspect;e[1]=0;e[2]=0;e[3]=0;e[4]=0;e[5]=s;e[6]=0;e[7]=0;e[8]=0;e[9]=0;e[10]=(far+near)*_f;e[11]=-1;e[12]=0;e[13]=0;e[14]=(2*far*near)*_f;e[15]=0;return this; } // 摄像机的“广角镜”：模拟人眼透视
    lookAt(ex, ey, ez, ax, ay, az, ux, uy, uz) { let e=this.e,fx=ax-ex,fy=ay-ey,fz=az-ez,r=Math.sqrt(fx*fx+fy*fy+fz*fz);fx/=r;fy/=r;fz/=r;let sx=fy*uz-fz*uy,sy=fz*ux-fx*uz,sz=fx*uy-fy*ux;r=Math.sqrt(sx*sx+sy*sy+sz*sz);sx/=r;sy/=r;sz/=r;let ux_r=sy*fz-sz*fy,uy_r=sz*fx-sx*fz,uz_r=sx*fy-sy*fx;e[0]=sx;e[1]=ux_r;e[2]=fx;e[3]=0;e[4]=sy;e[5]=uy_r;e[6]=fy;e[7]=0;e[8]=sz;e[9]=uz_r;e[10]=fz;e[11]=0;e[12]=-(sx*ex+sy*ey+sz*ez);e[13]=-(ux_r*ex+uy_r*ey+uz_r*ez);e[14]=-(fx*ex+fy*ey+fz*ez);e[15]=1;return this; } // 让“我”看向目标
    multiply(o) { let a=this.e,b=o.e,a00=a[0],a01=a[1],a02=a[2],a03=a[3],a10=a[4],a11=a[5],a12=a[6],a13=a[7],a20=a[8],a21=a[9],a22=a[10],a23=a[11],a30=a[12],a31=a[13],a32=a[14],a33=a[15];let b0=b[0],b1=b[1],b2=b[2],b3=b[3];this.e[0]=b0*a00+b1*a10+b2*a20+b3*a30;this.e[1]=b0*a01+b1*a11+b2*a21+b3*a31;this.e[2]=b0*a02+b1*a12+b2*a22+b3*a32;this.e[3]=b0*a03+b1*a13+b2*a23+b3*a33;b0=b[4];b1=b[5];b2=b[6];b3=b[7];this.e[4]=b0*a00+b1*a10+b2*a20+b3*a30;this.e[5]=b0*a01+b1*a11+b2*a21+b3*a31;this.e[6]=b0*a02+b1*a12+b2*a22+b3*a32;this.e[7]=b0*a03+b1*a13+b2*a23+b3*a33;b0=b[8];b1=b[9];b2=b[10];b3=b[11];this.e[8]=b0*a00+b1*a10+b2*a20+b3*a30;this.e[9]=b0*a01+b1*a11+b2*a21+b3*a31;this.e[10]=b0*a02+b1*a12+b2*a22+b3*a32;this.e[11]=b0*a03+b1*a13+b2*a23+b3*a33;b0=b[12];b1=b[13];b2=b[14];b3=b[15];this.e[12]=b0*a00+b1*a10+b2*a20+b3*a30;this.e[13]=b0*a01+b1*a11+b2*a21+b3*a31;this.e[14]=b0*a02+b1*a12+b2*a22+b3*a32;this.e[15]=b0*a03+b1*a13+b2*a23+b3*a33;return this; } // 矩阵们“手牵手”，叠加变换魔法
    setRotate(angle, x, y, z) { let e=this.e,s=Math.sin(angle*Math.PI/180),c=Math.cos(angle*Math.PI/180),r=Math.sqrt(x*x+y*y+z*z);if(r!==0){r=1/r;x*=r;y*=r;z*=r;}let nc=1-c,xy=x*y,yz=y*z,zx=z*x,xs=x*s,ys=y*s,zs=z*s;e[0]=x*x*nc+c;e[1]=xy*nc+zs;e[2]=zx*nc-ys;e[3]=0;e[4]=xy*nc-zs;e[5]=y*y*nc+c;e[6]=yz*nc+xs;e[7]=0;e[8]=zx*nc+ys;e[9]=yz*nc-xs;e[10]=z*z*nc+c;e[11]=0;e[12]=0;e[13]=0;e[14]=0;e[15]=1;return this; } // 让物体“旋转跳跃”
}

// 主控台：导演的舞台
window.onload = function() {
    const c = document.getElementById('glcanvas'), gl = getWebGLContext(c); // 召唤舞台和魔法师
    if (!gl) return;

    // 阴影片场着色器 (光源视角)
    const SV = 'attribute vec4 a_P;uniform mat4 u_Mvp;void main(){gl_Position=u_Mvp*a_P;}', // 顶点“位置”，光源的“视野矩阵”，计算顶点在光源眼中的位置
          SF = 'precision mediump float;void main(){gl_FragColor=vec4(gl_FragCoord.z,0,0,0);}'; // 片元“深度”，记录从光源到我的距离

    // 主片场着色器 (摄像机视角)
    const VV = 'attribute vec4 a_P;attribute vec4 a_C;uniform mat4 u_Mvp;uniform mat4 u_MvpL;varying vec4 v_PL;varying vec4 v_C;void main(){gl_Position=u_Mvp*a_P;v_PL=u_MvpL*a_P;v_C=a_C;}', // 顶点“位置”、“颜色”，摄像机和光源的“视野矩阵”，把颜色和光源视角位置传给片元
          FF = 'precision mediump float;uniform sampler2D u_SM;varying vec4 v_PL;varying vec4 v_C;void main(){vec3 sc=(v_PL.xyz/v_PL.w)*0.5+0.5;float d=texture2D(u_SM,sc.xy).r;float vis=(sc.z>d+0.005)?0.7:1.0;gl_FragColor=vec4(v_C.rgb*vis,v_C.a);}'; // 阴影贴图，“光源视角位置”，片元“颜色”，根据深度图判断我是不是被挡住了

    const sProg = createProgram(gl, SV, SF), // 阴影片场的“剧本”
          nProg = createProgram(gl, VV, FF); // 主片场的“剧本”

    sProg.a_P = gl.getAttribLocation(sProg, 'a_P'); sProg.u_Mvp = gl.getUniformLocation(sProg, 'u_Mvp'); // 阴影片场需要知道“位置”和“光源视野”
    nProg.a_P = gl.getAttribLocation(nProg, 'a_P'); nProg.a_C = gl.getAttribLocation(nProg, 'a_C');
    nProg.u_Mvp = gl.getUniformLocation(nProg, 'u_Mvp'); nProg.u_MvpL = gl.getUniformLocation(nProg, 'u_MvpL'); nProg.u_SM = gl.getUniformLocation(nProg, 'u_SM'); // 主片场需要“位置”、“颜色”、“摄像机视野”、“光源视野”和“深度图”

    // 准备演员们（顶点数据）：直接把他们的“站位”和“服装颜色”写下来
    const triV = new Float32Array([-0.8,3.5,0.0, 0.8,3.5,0.0, 0.0,3.5,1.8]), // 三角形演员的站位
          triC = new Float32Array([1,0.5,0, 1,0.5,0, 1,0,0]); // 三角形演员的服装颜色
    const plV = new Float32Array([3,-1.7,2.5, -3,-1.7,2.5, -3,-1.7,-2.5, 3,-1.7,2.5, -3,-1.7,-2.5, 3,-1.7,-2.5]), // 平面演员的站位 (两个三角形组成)
          plC = new Float32Array([1,1,1, 1,1,1, 1,1,1, 1,1,1, 1,1,1, 1,1,1]); // 平面演员的服装颜色

    const createB = (d, t) => { const b = gl.createBuffer(); gl.bindBuffer(t, b); gl.bufferData(t, d, gl.STATIC_DRAW); return b; }; // 创建缓冲区的“小助手”，把演员数据塞进去
    const triVB = createB(triV, gl.ARRAY_BUFFER), triCB = createB(triC, gl.ARRAY_BUFFER); // 三角形站位和服装的缓冲区
    const plVB = createB(plV, gl.ARRAY_BUFFER), plCB = createB(plC, gl.ARRAY_BUFFER); // 平面站位和服装的缓冲区

    // 秘密暗房 FBO：光影摄影师的专属摄影棚
    const FBO_S = 1024; // 暗房尺寸，决定照片清晰度
    const fb = gl.createFramebuffer(), tex = gl.createTexture(), db = gl.createRenderbuffer(); // 召唤暗房、照片（纹理）、深度记录员
    gl.bindTexture(gl.TEXTURE_2D, tex); gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, FBO_S, FBO_S, 0, gl.RGBA, gl.UNSIGNED_BYTE, null); // 准备一张空白照片，尺寸和格式
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); // 照片缩小时，模糊一点更自然
    gl.bindRenderbuffer(gl.RENDERBUFFER, db); gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, FBO_S, FBO_S); // 深度记录员准备好笔和纸，记录16位深度
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb); // 进入暗房
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0); // 让照片成为暗房的“画布”
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, db); // 让深度记录员在暗房里工作
    if(gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {console.log("暗房没搭好");return;} // 检查暗房是否完工
    gl.bindFramebuffer(gl.FRAMEBUFFER, null); gl.bindTexture(gl.TEXTURE_2D, null); gl.bindRenderbuffer(gl.RENDERBUFFER, null); // 离开暗房，整理好工具

    gl.clearColor(0, 0, 0, 1); gl.enable(gl.DEPTH_TEST); // 设置背景色为黑，开启深度测试，让近的物体挡住远的
    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, tex); // 把光影摄影师拍好的“深度照片”挂在“照片墙”的0号位置

    const lightPos = [0, 7, 2]; // 光源的位置：这个舞台的“太阳”在哪里？
    const m_L = new Matrix4().setPerspective(70, FBO_S/FBO_S, 1, 100).lookAt(...lightPos, 0,0,0, 0,1,0); // 光源的“世界观”：它从哪里看，看多远
    const m_C = new Matrix4().setPerspective(45, c.width/c.height, 1, 100).lookAt(0,7,9, 0,0,0, 0,1,0); // 摄像机的“世界观”：我们观众从哪里看，看多远

    const modelM = new Matrix4(), mvpM = new Matrix4(); // 模型的“姿态”（旋转平移），最终的“镜头效果”（MVP）
    let tri_mvpL = new Matrix4(), pl_mvpL = new Matrix4(); // 备份：从光源看的三角形和平面的“镜头效果”

    const setupAttrib = (attrLoc, buf, num, type) => { gl.bindBuffer(gl.ARRAY_BUFFER, buf); gl.vertexAttribPointer(attrLoc, num, type, false, 0, 0); gl.enableVertexAttribArray(attrLoc); }; // 属性配置“工人”：把演员的“站位”和“颜色”数据送到着色器里

    let angle = 0, last = Date.now(); // 动画计数器：记录舞台上物体旋转的时刻
    const tick = () => { // 导演的“每一秒”：不断地拍摄新画面
        const now = Date.now(); angle = (angle + (40 * (now - last) / 1000.0)) % 360; last = now; // 让三角形旋转

        // 第一阶段：光影摄影师拍照 (绘制深度图到秘密暗房)
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb); gl.viewport(0, 0, FBO_S, FBO_S); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // 切换到暗房，清空画板
        gl.useProgram(sProg); // 启用光影摄影师的“剧本”

        modelM.setRotate(angle, 0, 1, 0); mvpM.set(m_L).multiply(modelM); // 算出旋转后三角形在光源眼中的位置
        gl.uniformMatrix4fv(sProg.u_Mvp, false, mvpM.e); setupAttrib(sProg.a_P, triVB, 3, gl.FLOAT); gl.drawArrays(gl.TRIANGLES, 0, 3); // 绘制三角形的深度
        tri_mvpL.set(mvpM); // 保存三角形在光源眼中的“快照”

        modelM.setIdentity(); mvpM.set(m_L).multiply(modelM); // 算出平面在光源眼中的位置
        gl.uniformMatrix4fv(sProg.u_Mvp, false, mvpM.e); setupAttrib(sProg.a_P, plVB, 3, gl.FLOAT); gl.drawArrays(gl.TRIANGLES, 0, 6); // 绘制平面的深度
        pl_mvpL.set(mvpM); // 保存平面在光源眼中的“快照”

        // 第二阶段：主摄影师出片 (绘制最终场景到屏幕)
        gl.bindFramebuffer(gl.FRAMEBUFFER, null); gl.viewport(0, 0, c.width, c.height); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // 切换回大舞台，清空画面
        gl.useProgram(nProg); gl.uniform1i(nProg.u_SM, 0); // 启用主摄影师的“剧本”，并告诉他深度照片在0号“照片墙”

        modelM.setRotate(angle, 0, 1, 0); mvpM.set(m_C).multiply(modelM); // 算出旋转后三角形在摄像机眼中的位置
        gl.uniformMatrix4fv(nProg.u_Mvp, false, mvpM.e); gl.uniformMatrix4fv(nProg.u_MvpL, false, tri_mvpL.e); // 告诉主摄影师三角形的“光源快照”
        setupAttrib(nProg.a_P, triVB, 3, gl.FLOAT); setupAttrib(nProg.a_C, triCB, 3, gl.FLOAT); gl.drawArrays(gl.TRIANGLES, 0, 3); // 绘制三角形（带阴影）

        modelM.setIdentity(); mvpM.set(m_C).multiply(modelM); // 算出平面在摄像机眼中的位置
        gl.uniformMatrix4fv(nProg.u_Mvp, false, mvpM.e); gl.uniformMatrix4fv(nProg.u_MvpL, false, pl_mvpL.e); // 告诉主摄影师平面的“光源快照”
        setupAttrib(nProg.a_P, plVB, 3, gl.FLOAT); setupAttrib(nProg.a_C, plCB, 3, gl.FLOAT); gl.drawArrays(gl.TRIANGLES, 0, 6); // 绘制平面（带阴影）

        requestAnimationFrame(tick); // 导演喊：“下一场，继续！”
    };
    tick(); // 动画开始
};
</script>
</body>
</html>