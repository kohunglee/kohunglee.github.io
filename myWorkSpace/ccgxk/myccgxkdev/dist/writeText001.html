
<!DOCTYPE html>
<html>
<head>
    <title>Canvas多行文本示例</title>
    <style>
        body { display: flex; justify-content: center; padding: 20px; }
        canvas { border: 1px solid #ccc; margin: 10px; }
        .controls { margin-left: 20px; }
        textarea { width: 300px; height: 150px; margin-bottom: 10px; }
    </style>
</head>
<body>
    <canvas id="textCanvas" width="400" height="300"></canvas>
    
    <div class="controls">
        <textarea id="textInput">日本肉香毁了~
为啥这么香
香憨</textarea><br>
        <button onclick="updateText()">更新文字</button>
    </div>

    <script>
        const canvas = document.getElementById('textCanvas');
        const ctx = canvas.getContext('2d');
        
        // 写字函数
        function drawText(ctx, value, width, height, index/* OBJ索引 */, id/* 图片ID */, _this){

            const boxAlignType = 2;  // 1:左上 2:左下 3:右上 4:右下
            const typeObj = {
                xOffset : 0,
                yOffset : 0.4,
            };
            ctx.font = typeObj.font || "25px Arial";                  // 字体大小和类型
            ctx.fillStyle =  typeObj.fillStyle || "black";            // 填充颜色
            ctx.strokeStyle =  typeObj.strokeStyle || "black";        // 描边颜色
            ctx.textAlign =  typeObj.textAlign || "left";             // 水平对齐方式（left/center/right）

            ctx.textBaseline =  typeObj.textBaseline ||"top";         // 垂直对齐方式（top/middle/bottom）
            var lineHeight = parseInt(ctx.font) || 25;
            const margin = 10;  // 边距
            const marginLeft = 10;  // 边距
            const marginTop = 10;
            ctx.clearRect(0, 0, width, height);  // 透明色
            ctx.fillStyle = 'black';

            
            
            // 简单排版函数
            function wrapText(_ctx, text, x, y, maxWidth, lineHeight) {
                const words = text.split(''); // 按单个字符来拆分，保证中英文都能换行
                let line = ''; // 当前正在排版的行内容
                for(let n = 0; n < words.length; n++) {
                    if (words[n] === '\n') {  //+ 处理 \n 来换行的逻辑
                        _ctx.fillText(line, x, y);
                        y += lineHeight;line = '';
                        continue;
                    }
                    if(words[n] === '#'){  // 本行内有 @, 则本行颜色为蓝色
                        ctx.fillStyle = 'blue';
                        ctx.font = "40px serif";
                        lineHeight = 43;
                        words[n] = '';
                    }
                    if(words[n] === '%'){  // 本行内有 @, 则本行颜色为红色
                        ctx.fillStyle = 'red';
                        ctx.font = "40px serif";
                        lineHeight = 43;
                        words[n] = '';
                    }
                    if(words[n] === '@'){  // 本行内有 #, 则本行格式为默认
                        ctx.fillStyle = 'black';
                        ctx.font = typeObj.font || "25px Arial";
                        lineHeight = 25;
                        words[n] = '';
                    }
                    const testLine = line + words[n];  //+ 长度够了，换行的逻辑
                    const metrics = _ctx.measureText(testLine);  // 计算长度
                    const testWidth = metrics.width;
                    if (testWidth > maxWidth && n > 0) {  // 超长了
                        _ctx.fillText(line, x, y);
                        line = words[n];  // 另起一行
                        y += lineHeight;
                    } else {
                        line = testLine;
                    }
                }
                _ctx.fillText(line, x, y);  // 最后剩下的一行
            }
            wrapText(ctx, value, marginLeft + width * typeObj.xOffset, marginTop + width * typeObj.yOffset, width - margin * 2, lineHeight);
        }










        /* ------------------------------------------ */

        // 初始绘制
        drawText(ctx, document.getElementById('textInput').value, 400, 300);
        
        // 更新文字
        function updateText() {
            const newText = document.getElementById('textInput').value;
            drawText(ctx, newText, 400, 300);
        }
    </script>
</body>
</html>
